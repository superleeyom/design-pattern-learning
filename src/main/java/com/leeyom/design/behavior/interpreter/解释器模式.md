## 解释器模式

### 类图

![](http://image.leeyom.top/blog/20200909223631.png)

- `AbstractExpression`：抽象解释器，具体的解释任务由各个实现类完成，具体的解释器分别由TerminalExpression和Non-terminalExpression完成。
- `NonterminalExpression`：非终结符表达式，文法中的每条规则对应于一个非终结表达式，具体到我们的例子就是加减法规则分别对应到AddExpression和SubExpression两个类。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。
- `Context`：环境角色，具体到我们的例子中是采用HashMap代替。

### 定义

- 给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

### 优点

- 解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了。

### 缺点

- 解释器模式会引起类膨胀
- 解释器模式采用递归调用方法
- 效率问题，解释器大量使用循环和递归

### 使用场景

- 一个简单语法需要解释的场景：
    - 例如示例中的加减法的解释器
- 重复发生的问题可以使用解释器模式：
    - 例如，多个应用服务器，每天产生大量的日志，需要对日志文件进行分析处理，由于各个服务器的日志格式不同，但是数据要素是相同的，按照解释器的说法就是终结符表达式都是相同的，但是非终结符表达式就需要制定了。

### 注意事项

- 尽量不要在重要的模块中使用解释器模式，否则维护会是一个很大的问题。在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足。