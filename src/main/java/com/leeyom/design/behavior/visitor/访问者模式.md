## 访问者模式

### 类图

![访问者模式](http://image.leeyom.top/blog/20200905173448.png)

- Visitor：抽象访问者，用于声明可以访问哪些元素
- ConcreteVisitor：具体的访问者，它影响访问者访问到一个类后该怎么干，要做什么事情
- Element：抽象元素，理解为被访问者的抽象类，接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的
- ConcreteElement：具体元素，具体被访问者的实现，实现accept方法，通常是visitor.visit(this)，基本上都形成了一种模式了
- ObjectStruture：结构对象，元素产生者，一般容纳在多个不同类、不同接口的容器，如List、Set、Map等，在项目中，一般很少抽象出这个角色

### 定义

- 访问者模式（Visitor Pattern）是一个相对简单的模式，其定义如下：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。

### 优点

- 符合单一职责原则：例如示例中，具体元素角色也就是Employee抽象类的两个子类负责数据的加载，而Visitor类则负责报表的展现。
- 优秀的扩展性：由于职责分开，继续增加对数据的操作是非常快捷的，例如，现在要增加一份给大老板的报表，这份报表格式又有所不同，直接在Visitor中增加一个方法，传递数据后进行整理打印。
- 灵活度高

### 缺点

- 具体元素需要对访问者公布细节：
    - 访问者要访问一个类就必然要求这个类公布一些方法和数据，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的。
- 具体的元素变更比较困难：
    - 具体元素角色的增加、删除、修改都是比较困难的，就上面那个例子，你想想，你要是想增加一个成员变量，如年龄age，Visitor就需要修改，如果Visitor是一个还好办，多个呢？业务逻辑再复杂点呢？
- 违背依赖倒置原则：
    - 访问者依赖的是具体元素，而不是抽象元素，这破坏了依赖倒置原则，特别是在面向对象的编程中，抛弃了对接口的依赖，而直接依赖实现类，扩展比较难。
    
### 使用场景

- 在这种地方你一定要考虑使用访问者模式：**业务规则要求遍历多个不同的对象**。这本身也是访问者模式出发点，迭代器模式只能访问同类或同接口的数据（当然了，如果你使用instanceof，那么能访问所有的数据，这没有争论），而访问者模式是对迭代器模式的扩充，可以遍历不同的对象，然后执行不同的操作，也就是针对访问的对象不同，执行不同的操作。