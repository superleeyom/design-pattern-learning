## 策略模式

### 类图

![策略模式](http://image.leeyom.top/blog/20200809103904.png)

- Context封装角色：它也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。
- Strategy抽象策略角色：策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。
- ConcreteStrategy具体策略角色：实现抽象策略中的操作，该类含有具体的算法。

### 定义

- 定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。

### 优点

- 避免使用多重条件判断：使用策略模式后，可以由其他模块决定采用何种策略，策略家族对外提供的访问接口就是封装类，简化了操作，同时避免了条件语句判断。
- 自由切换策略：只要实现抽象策略，它就成为策略家族的一个成员，通过封装角色对其进行封装，保证对外提供“可自由切换”的策略。
- 扩展性良好：现有的系统中增加一个策略太容易了，只要实现接口就可以了，其他都不用修改，类似于一个可反复拆卸的插件，这大大地符合了OCP原则。

### 缺点

- 策略类数量增多，每一个策略都是一个类，复用的可能性很小，类数量增多。
- 所有的策略类需要对外暴露，上层必须知道有哪些策略，才决定使用哪个策略，但是我们可以使用其他模式来修正这个缺陷，如工厂方法模式、代理模式或享元模式。

### 使用场景

- 多个类只有在算法或行为上稍有不同的场景。
- 多重条件判断的时候，也就是if-else特别多的时候，可以考虑使用策略模式+工厂方法模式。

### 注意事项

- 如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题，否则日后的系统维护就会成为一个烫手山芋，谁都不想接。
    - 解决方案：通过简单工厂可以解决策略模式需要上层调用者对于策略类的依赖问题，但是策略类的膨胀问题，我觉得只能从业务上做限制了，简化业务流程。